---
title: "Bioinformatics Approaches to Regulatory Genomics and Epigenomics 2025 Project"
author: "Julia Frank, Jesslyn Jesslyn, Sara Leka"
date: "2025-06-24"
output: 
  html_document:
    code_folding: hide
bibliography: project_references.bib
link-citations: TRUE 
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

Myofibers are the main structural and functional units of skeletal muscle. They are highly adaptive cells that vary widely in size, metabolic activity, and functional properties. This adaptability is reflected in their transcriptomic and epigenomic landscapes, which can shift significantly in response to physiological and pathological conditions. Understanding these regulatory changes offers insights into how skeletal muscle adapts, regenerates, and deteriorates under different conditions.\
In this context, ATAC-seq data is a powerfool tool to study chromatin accessibility. When applied to single myofibers, this technique provides sufficient resolution and depth for downstream epigenetic analysis without the presence of confounding muscle resident cell types. This approach was conducted in the study "Application of ATAC-Seq for genome-wide analysis of the chromatin state at single myofiber resolution" by [@sahinyan2022atac]. In their work, they used single-myofiber ATAC-seq (smfATAC-seq) to profile chromatin accessibility in myofibers under various physiological and disease conditions.\
The aim of our project is to reproduce and critically evaluate key aspects of that study. We focus on two biologically relevant comparisons: uninjured (UI) vs. injured (I) myofibers, and wild-type (WT) vs. dystrophic (MDX) myofibers. The UI vs. I comparison allows us to explore how myofibers change their chromatin landscape during regeneration following cardiotoxin-induced injury. The WT vs. MDX comparison highlights the epigenomic consequences of Duchenne Muscular Dystrophy (DMD), for which the MDX mouse serves as a widely used model.\
Our pipeline covers the full pre-processing of raw ATAC-seq data, including quality control, alignment, filtering, peak calling, and normalization. We then assess data quality and consistency through correlation analysis, followed by differential accessibility analysis, gene set enrichment analysis and motif discovery to interpret the biological significance of the observed changes.

# Methods & Results

## Load packages

At first, all necessary packages were installed and loaded. Information on the package versions used can be found in the Appendix.

```{r}
suppressPackageStartupMessages({
  library(GenomicRanges)
  library(rtracklayer)
  library(epiwraps)
  library(AnnotationHub)
  library(ensembldb)
  library(ggplot2)
  library(tidyverse)
  library(DESeq2)
  library(pheatmap)
  library(RColorBrewer)
  library(pheatmap)
  library(gridExtra)
  library(ggpubr)
  library(grid)
  library(limma)
  library(edgeR)
  library(MotifDb)
  library(universalmotif)
  library(data.table)
  library(GenomicRanges)
  library(TFBSTools)
  library(AnnotationHub)
  library(Biostrings)
})
```

## The data

The pipeline processes single myofiber ATAC-seq data obtained from the EDL muscle of Mus musculus. The raw data is available through the [SRA Run Selector](https://www.ncbi.nlm.nih.gov/Traces/study/?acc=PRJNA726576&o=acc_s%3Aa) while the authors provide just their processed coverage tracks on [GEO](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE173676)\
The dataset is divided into two distinct and independent experiments, each representing a separate biological context and likely processed at different times. \

Experiment 1 - muscle regeneration:\

- **UI1–2**: 2 uninjured control myofibers.
- **I1–3**: 3 injured myofibers (harvested 7 days after acute injury, representing the regenerating state).\

Experiment 2 – muscular dystrophy:\

- **MDX1–3**: 3 myofibers from MDX mice, a standard mouse model for Duchenne muscular dystrophy (DMD), characterized by chronic muscle degeneration.
- **WT1–4**: 4 myofibers from wild-type (WT) healthy control mice.

A joint analysis across all four conditions would have been informative, but the experimental design introduces batch effects that make it difficult to distinguish technical variation from true biological differences. In fact, there is not a common condition across the two experiments. While a possible solution to overcome this would have been combining the UI data from the first batch with the WT data from the second one, assuming they are the same would have been risky given that the authors of the data do not clearly state this equivalence. \
To mantain clarity and avoid confounding due to batch effects, the two experimental setups are therefore analyzed independently: one comparing uninjured and injured myofibers, and the other comparing WT and MDX myofibers.

## Preprocessing

NB: drive points to Jesslyn's coverage traks

In order to generate all the data needed downstream (peaks, counts, coverage tracks) we processed the raw data. Since preprocessing is quite computationally and memory intensive, we performed it on Euler. All code scripts and resulting data are available in the `preprocessing` folder. The coverage tracks were too large for GitHub, so we uploaded them to [Google Drive](https://1drv.ms/f/c/ad47ab1cb526b6da/EiGJACKkCqhAqehU3_HI-AMBXvwKSJhkNprIwYIos2Fupg?e=tbCstp). If you want to rerun the R script, please download the coverage tracks and place them in `preprocessing`\>`results`\>`tracks`.

### 1. Trimming

NB: refers to Jesslyn's multiqc reports and adapters used

Raw `.sra` files were converted to `.fastq.gz`, followed by adapter trimming using the `trimmomatic` package. Specifically, Illumina NexteraPE-PE adapters were removed. Quality control was performed both before and after trimming using `FastQC` and summarized with `MultiQC`.

knitr::include_graphics(c("images/fastqc_adapter_content_plot.png", "images/fastqc_adapter_content_plot_post.png"))

### 2. Alignment

NB: plot refers to Sara's alignment (I didn't have the stats from Jesslyn)

Trimmed reads were aligned to the mm10 mouse genome using `bowtie2`, followed by filtering, sorting, and indexing with `samtools`. Only uniquely mapping reads were retained. The `.bam` files were then filtered for high-quality, uniquely mapped reads (MAPQ ≥ 20), and PCR duplicates were removed using `Picard`. Read groups were added to comply with downstream processing tools. Final sorting and indexing was performed with `samtools`. 

knitr::include_graphics("images/bam_summaryplot.png")

### 3. Peak calling

Peaks were called using `MACS3` on each individual `.bam` file, generating `.narrowPeak` files representing regions of open chromatin.

### 4. Count Matrix Generation

To compare chromatin accessibility between conditions, we first combined the peak files from all replicates of each experiment (UI vs. I and WT vs. MDX). We then merged overlapping peaks to create a consensus peak set for each comparison. These consensus peaks represent regions that were accessible in at least one of the samples. Next, we counted how many reads from each sample overlapped with each consensus peak to create a count matrix.

### 5. Coverage Track Generation

For visualization and downstream analyses, normalized bigWig coverage tracks were generated using `bamCoverage` from the `deepTools` suite. 

### 6. Load the Preprocessed Data

For the subsequent analysis, we load the merged coverage tracks and count matrices from both experiments into this R Markdown document.

```{r load data}
# Change the ouput size to look nicer
options(width = 150)

# Define folder structure
tracks_path <-"preprocessing/results/tracks"
mat_path <-"preprocessing/results/count_matrix"

# Load the merged coverage tracks for all experimental conditions
tracks <- list(
  Uninjured=paste0(tracks_path, "/uninjured_merged.bw"),
  Injured=paste0(tracks_path, "/injured_merged.bw"),
  WT=paste0(tracks_path, "/wt_merged.bw"),
  MDX=paste0(tracks_path, "/mdx_merged.bw")
)

# Define the sample names
names1 <- c("Uninjured_1", "Uninjured_2", "Injured_1", "Injured_2", "Injured_3")
names2 <- c("MDX_1", "MDX_2", "MDX_3", "WT_1", "WT_2", "WT_3", "WT_4")

# Read in the data table, skipping the first comment lines
counts1 <- read.delim(paste0(mat_path, "/counts_UI_I.txt"), comment.char="#", stringsAsFactors=FALSE)
counts2 <- read.delim(paste0(mat_path, "/counts_MDX_WT.txt"), comment.char="#", stringsAsFactors=FALSE)

# Rename the columns
colnames(counts1)[7:ncol(counts1)] <- names1
colnames(counts2)[7:ncol(counts2)] <- names2

# Set rownames to peak ID
rownames(counts1) <- counts1$Geneid
counts1$Geneid <- NULL
rownames(counts2) <- counts2$Geneid
counts2$Geneid <- NULL


# Look at the data
#cat("First few rows of the count matrix for uninjured vs. injured samples:\n")
#head(counts1)
#cat("First few rows of the count matrix for MDX vs. WT samples:\n")
#head(counts2)
```

## Data Validation

We plotted the enrichment of ATAC-seq signal around transcription start sites (TSSs) to assess data quality and validate that our assay accurately captured regions of open chromatin. Since TSSs are typically located in accessible, nucleosome-depleted regions of active genes, we expected to observe strong signal enrichment at these sites.

```{r TSS enrichment}
# 1. Load the Ensembl Transcript Database for mouse
ah <- AnnotationHub()

# 2. Search for relevant datasets
# Note: GRCm38 is the same genome assembly as mm10 used for alignment
q <- query(ah, c("Mus musculus", "EnsDb", "GRCm38"))

# 3. Retrieve metadata for all available versions
meta <- mcols(q)[, c("rdatadateadded", "title", "genome", "tags", "rdatapath")]

# 4. Select the newest version
ensdb <- ah[["AH83247"]]

# 5. Load transcripts (protein-coding only)
txs <- transcripts(ensdb, filter = TxBiotypeFilter("protein_coding"))

# 6. Fix chromosome naming by adding 'chr' prefix where appropriate
seqlevels(txs) <- ifelse(seqlevels(txs) %in% c(as.character(1:19), "X", "Y", "MT"),
                        paste0("chr", seqlevels(txs)),
                        seqlevels(txs))

# 7. Keep only chromosomes shared between annotation and BigWig files
bw_seqinfo <- seqinfo(BigWigFile(tracks[[1]]))
common_seqlevels <- intersect(seqlevels(txs), seqlevels(bw_seqinfo))
txs <- keepSeqlevels(txs, common_seqlevels, pruning.mode = "coarse")

# 8. Get transcription start site (TSS) positions
tss <- GenomicRanges::reduce(promoters(txs, upstream = 0, downstream = 1))

# 9. Compute signal matrix around TSS
tss_matrix <- epiwraps::signal2Matrix(tracks, granges(tss), w = 10, extend = 1000)
title <- " Enrichment at transcription start site (TSS)"

# 10. Plot heatmap of the enrichment signals
hm <- epiwraps::plotEnrichedHeatmaps(tss_matrix, trim = 0.95, colors = c("white", "darkred"), 
                                    multiScale = TRUE, axis_name = "TSS")
draw(hm, column_title = title)
```

The heatmap shows a clear enrichment of ATAC-seq signal at transcription start sites (TSS), indicating that chromatin accessibility is highest near gene promoters. This pattern confirms the expected biological behavior, where regulatory elements around the TSS are more open and accessible for transcription machinery binding. The slight upstream shift of the peaks suggests that many transcription factors preferentially bind just before the TSS.

## Replicate Comparison and Clustering

### Normalization

The raw count data was then normalized using the regularized log (rlog) transformation from the DESeq2 package, which stabilizes variance across samples, especially for genes with low counts.

```{r normalization}
# Function to normalize count data using rlog transformation from DESeq2
process_mat <- function(mat) {
  # Extract count columns starting from the 6th column onward (rest is meta data)
  count_data <- mat[, 6:ncol(mat)]
  
  # Convert count data to a numeric matrix
  count_data <- as.matrix(count_data)
  mode(count_data) <- "numeric"
  
  # Construct a DESeq2 dataset object without any experimental design
  dds <- DESeqDataSetFromMatrix(
    countData = count_data,
    colData = DataFrame(row.names = colnames(count_data)),
    design = ~1  # No experimental grouping; used for transformation only
  )
  
  # Apply rlog transformation (variance-stabilizing, blind to design)
  rlog_counts <- rlog(dds, blind = TRUE)
  
  # Extract the transformed (normalized) count matrix
  norm_mat <- assay(rlog_counts)
  
  # Replace any NA values with 0
  norm_mat[is.na(norm_mat)] <- 0
  
  return(norm_mat)
}

# Normalize counts for the "Uninjured vs. Injured" experiment
norm_counts1 <- process_mat(counts1)
#cat("First few rows of the normalized count matrix for uninjured vs. injured samples:\n")
#head(norm_counts1)

# Normalize counts for the "MDX vs. WT" experiment
norm_counts2 <- process_mat(counts2)
#cat("First few rows of the normalized count matrix for MDX vs. WT samples:\n")
#head(norm_counts2)
```

### Pearson correlation heatmaps

Pearson correlation heatmaps were generated from the normalized count data to evaluate the similarity between replicates within each experimental condition.

```{r correlation heatmap}
# PEARSON CORRELATION HEATMAPS

# Compute Pearson correlation matrices for normalized counts
cor_mat1 <- cor(norm_counts1, method = "pearson")
cor_mat2 <- cor(norm_counts2, method = "pearson")

# Define cell size for consistent heatmap appearance
cell_size <- 24

# Generate heatmap for the Uninjured vs. Injured comparison
hm1 <- pheatmap(
  cor_mat1,
  cluster_rows = FALSE,
  cluster_cols = FALSE,
  main = "Uninjured vs. Injured",
  col = colorRampPalette(brewer.pal(9, "Blues"))(100),
  silent = TRUE,
  cellwidth = cell_size,
  cellheight = cell_size
)

# Generate heatmap for the MDX vs. WT comparison
hm2 <- pheatmap(
  cor_mat2,
  cluster_rows = FALSE,
  cluster_cols = FALSE,
  main = "MDX vs. WT",
  col = colorRampPalette(brewer.pal(9, "Blues"))(100),
  silent = TRUE,
  cellwidth = cell_size,
  cellheight = cell_size
)

# Arrange both heatmaps side by side in a single figure
grid.arrange(
  grobs = list(hm1$gtable, hm2$gtable),
  ncol = 2,
  widths = c(1, 1),
  top = textGrob("Pearson correlation between replicates", gp = gpar(fontsize = 16, fontface = "bold"))
)

```

Overall, the Pearson correlation is very high for all samples, with correlation coefficients consistently above 0.95 regardless of condition. In the Uninjured vs. Injured experiment, the injured replicates clearly cluster more closely together than with the uninjured ones. However, the uninjured replicates appear more similar to the injured samples than to the other uninjured replicate. For the MDX vs. WT experiment, there is no clear difference in correlation between replicates of the same condition compared to samples from the other condition.

### Principal Component Analysis (PCA)

Next, we performed a Principal Component Analysis to visualize how close the samples cluster together.

```{r pca, fig.width=10, fig.height=5}
# PCA

# Function to extract condition based on the sample name
get_conditions <- function(colnames_vec) {
  substr(colnames_vec, 1, nchar(colnames_vec) - 2)
}

# Function to generate PCA plot
plot_pca <- function(norm_signal, subtitle_text) {
  sample_names <- colnames(norm_signal)
  sample_conditions <- get_conditions(sample_names)
  
  # Perform PCA on transposed data (samples as rows)
  pca <- prcomp(t(norm_signal), scale. = FALSE)
  
  # Calculate percentage of variance explained by PC1 and PC2
  var_explained <- round((pca$sdev^2 / sum(pca$sdev^2))[1:2] * 100, 1)
  
  # Create data frame for ggplot input
  pca_df <- data.frame(
    PC1 = pca$x[,1],
    PC2 = pca$x[,2],
    Sample = sample_names,
    Condition = sample_conditions
  )
  
  # Create PCA scatter plot with labels and styling
  ggplot(pca_df, aes(PC1, PC2, color = Condition, label = Sample)) +
    geom_point(size = 4) +                           
    geom_text(vjust = -1, hjust = 0.5, size = 5) +  
    coord_cartesian(clip = "off") +                
    theme_minimal(base_size = 20) +                 
    labs(
      x = paste0("PC1 (", var_explained[1], "% variance)"),
      y = paste0("PC2 (", var_explained[2], "% variance)"),
      subtitle = subtitle_text                      
    ) +
    theme(
      plot.subtitle = element_text(size = 20, hjust = 0.5, face = "bold"),
      legend.position = "bottom",
      legend.text = element_text(size = 14),
      legend.title = element_text(size = 16),
      legend.key.size = unit(0.6, "cm"),
      axis.title = element_text(size = 18),
      axis.text = element_text(size = 14),
      plot.margin = margin(10, 10, 10, 10)           
    )
}

# Generate individual PCA plots for both datasets
pca_plot1 <- plot_pca(norm_counts1, "Uninjured vs. Injured")
pca_plot2 <- plot_pca(norm_counts2, "MDX vs. WT")

# Combine the two plots side-by-side 
final_plot <- ggarrange(
  pca_plot1, pca_plot2,
  ncol = 2, nrow = 1,
  common.legend = FALSE
)

# Add an overall title above the combined figure
annotate_figure(
  final_plot,
  top = text_grob("PCA of Samples", face = "bold", size = 24, hjust = 0.5)
)

```

In the PCA plots, samples clearly separate based on their experimental conditions, indicating distinct chromatin accessibility profiles.

### Hierarchical Clustering between replicates

```{r hierarchical clustering, fig.width=8, fig.height=4}
# HIERARCHICAL CLUSTERING

# Function to perform hierarchical clustering and plot dendrogram 
plot_hclust <- function(norm_signal, plot_title) {
  # Calculate distance matrix between samples (columns)
  dist_mat <- dist(t(norm_signal))
  
  # Perform hierarchical clustering on the distance matrix
  hc <- hclust(dist_mat)
  
  # Plot the dendrogram
  plot(hc, main = plot_title, xlab = "", sub = "", cex = 0.8, font.main = 1) 
}

# Set up plotting area to have 1 row and 2 columns for side-by-side plots
# Adjust outer margins (oma) to provide space for the overall title above both plots
# Adjust inner margins (mar) to fit axis labels and titles nicely
par(mfrow = c(1, 2), oma = c(1, 1, 4, 1), mar = c(4, 4, 2, 1))

# Generate hierarchical clustering dendrograms for both datasets
hc1 <- plot_hclust(norm_counts1, "Uninjured vs. Injured")
hc2 <- plot_hclust(norm_counts2, "MDX vs. WT")

# Add a main title above the two plots
mtext("Hierarchical Clustering of Samples", side = 3, outer = TRUE, line = 1, cex = 1.5)

# Reset plotting parameters to default (single plot, no outer margin adjustments)
par(mfrow = c(1, 1), oma = c(0, 0, 0, 0))

```

As noted in the Pearson Correlation Heatmaps, the injured replicates cluster tightly together, while the uninjured replicates do not cluster as closely with each other and instead appear closer to the injured samples. In the MDX vs. WT comparison, not all WT replicates cluster more closely together than with MDX samples, but overall, most replicates tend to group closer to their own condition than to the other.

## Differential accessibility analysis

```{r}
# Function to get the same results for all DE
process_and_plot_results <- function(res_df, res = NULL, method_name = "Method", 
                                     normalized_counts = NULL) {
  
  # Remove rows with missing values in results (e.g., NA p-values)
  res_df <- na.omit(res_df)
  
  # Adjust p-values and clip them
  res_df$padj <- p.adjust(res_df$pvalue, method = "bonferroni")
  # Clip p-values
  res_df$padj <- ifelse(res_df$padj < 1e-50, 1e-50, res_df$padj) 
  
  # Mark significant genes based on thresholds
  res_df$significant <- ifelse(abs(res_df$logFC) > 1 & 
                              res_df$padj < 0.05, "Significant", "Not Significant")
  
  
  # Visualize results
  # 1. MA Plot
  if (!is.null(res) & method_name != "limma"){
    plotMA(res, main = paste("MA Plot (", method_name, ")", sep = ""))
  } else if ((!is.null(res)) & (method_name == "limma")){
    limma::plotMA(res, main = paste("MA Plot (", method_name, ")", sep = ""))
  }
  
  # Create Volcano Plot
  volcano <- ggplot(res_df, aes(x = logFC, y = -log10(padj))) +
    geom_point(aes(color = significant), alpha = 0.7, size = 1) +
    scale_color_manual(values = c("gray", "maroon")) +
    theme_minimal() +
    labs(
      title = paste("Volcano Plot (", method_name, ")", sep = ""),
      x = "Log2 Fold Change",
      y = "-Log10 (Bonferroni corrected p-value)"
    )
  print(volcano)
  
  # Select top genes
  top_genes <- rownames(res_df[order(res_df$padj), ])[abs(res_df$logFC) > 2]
  top_genes <- top_genes[1:min(50, length(top_genes))]
  
  # Heatmap of top differentially expressed genes
  if (!is.null(normalized_counts)) {  # Check for normalized counts
    pheatmap(normalized_counts[top_genes, ], cluster_rows = TRUE, 
             cluster_cols = TRUE, 
             main = paste("Heatmap of Top Genes (", method_name, ")", sep = ""))
  }
  
  # Extract significant DEGs
  significant_genes <- rownames(res_df[res_df$significant == "Significant", ])
  return(significant_genes)
}
```

```{r}
run_limma_voom <- function(count_mat, baseline_condition) {
  # 1. Extract numeric count matrix
  count_data <- as.matrix(count_mat)
  mode(count_data) <- "numeric"
  
  # 2. Extract condition from column names (e.g., "WT_1", "WT_2")
  condition <- substr(colnames(count_data), 1, nchar(colnames(count_data)) - 2)
  condition <- factor(condition)
  condition <- relevel(condition, ref = baseline_condition)
  
  # 3. Create DGEList object
  dge <- DGEList(counts = count_data, group = condition)
  
  # 4. Filter out lowly expressed peaks
  keep <- filterByExpr(dge)
  dge <- dge[keep, , keep.lib.sizes = FALSE]
  
  # 5. Normalize using TMM
  dge <- calcNormFactors(dge)
  
  # 6. Create design matrix
  design <- model.matrix(~ condition)
  print("Design matrix head:")
  print(head(design))
  
  # 7. Voom transformation
  v <- voom(dge, design = design, plot = TRUE)
  
  # 8. Fit linear model
  fit <- lmFit(v, design)
  fit <- eBayes(fit)
  
  # 9. Extract results (condition effect = coef 2)
  results <- topTable(fit, coef = 2, number = Inf, sort.by = "P")
  results_df <- as.data.frame(results)
  results_df$gene <- rownames(results_df)
  results_df$pvalue <- results$P.Value
  
  # 10. Optionally process and visualize results
  limma_DEGs <- process_and_plot_results(results_df, res = fit, method_name = "limma", normalized_counts = v$E)
  
  # 11. Return results
  return(list(results = results_df, DEGs = limma_DEGs))
}
```

```{r}
run_deseq2 <- function(count_mat, baseline_condition, contrast_condition) {
  # 1. Convert to numeric matrix
  count_data <- as.matrix(count_mat)
  mode(count_data) <- "numeric"
  
  # 2. Extract condition from column names (e.g., "WT_1", "WT_2")
  condition <- substr(colnames(count_data), 1, nchar(colnames(count_data)) - 2)
  
  # 3. Set up condition factor and relevel
  condition <- factor(condition)
  condition <- relevel(condition, ref = baseline_condition)
  
  # 4. Create metadata
  metadata <- data.frame(row.names = colnames(count_data), condition = condition)
  
  # 5. Create DESeqDataSet
  dds <- DESeqDataSetFromMatrix(countData = count_data,
                                colData = metadata,
                                design = ~ condition)
  
  # 6. Filter lowly accessible peaks
  dds <- dds[rowSums(counts(dds)) >= 1, ]
  
  # 7. Run DESeq2
  dds <- DESeq(dds)
  
  # 8. Extract results for contrast
  res <- results(dds, contrast = c("condition", contrast_condition, baseline_condition))
  res_df <- as.data.frame(res)
  res_df$gene <- rownames(res_df)
  res_df$logFC <- res$log2FoldChange  # Rename for consistency
  res_df$pvalue <- res$pvalue
  normalized_counts <- assay(vst(dds, blind = FALSE))  # Variance stabilizing transformation
  
  # 9. Extract significant DEGs from DESeq2
  DESeq2_DEGs <- process_and_plot_results(res_df, res, method_name = "DESeq2", normalized_counts)
  
  # 10. Return results
  return(list(results = res_df, DEGs = DESeq2_DEGs))
}

```

### Uninjured vs. Injured Experiment

```{r}
# Now apply the function to your two datasets:

# Dataset 1: baseline = "Uninjured"
res1_limma <- run_limma_voom(counts1[, 6:ncol(counts1)], baseline_condition = "Uninjured")
res1_des <- run_deseq2(counts1[, 6:ncol(counts1)], baseline_condition = "Uninjured", contrast_condition = "Injured")


```

```{r}
# Dataset 2: baseline = "WT"
res2 <- run_limma_voom(counts2[, 6:ncol(counts2)], baseline_condition = "WT")
res2_des <- run_deseq2(counts2[, 6:ncol(counts2)], baseline_condition = "WT", contrast_condition = "MDX")
```

## Gene set enrichment analysis

## Motif enrichment analysis
```{r define required functions}
## Function to clean granges
clean_seqlevels <- function(granges){
  granges <- keepSeqlevels(granges, common_seqlevels, pruning.mode = "coarse")
  return(granges)
}

## Function to obtain common and unique peaks between two GRanges objects
obtain_peaks <- function(cond1, cond2){
  # Find overlaps
  hits <- findOverlaps(cond1, cond2)
  
  # Common peaks: intersect overlapping regions
  common_cond1 <- cond1[(queryHits(hits))]
  common_cond2  <- cond2[(subjectHits(hits))]
  common_peaks <- pintersect(common_cond1, common_cond2) #since exact peak region used
  common_peaks <- clean_seqlevels(common_peaks)
  
  # Unique peaks for cond1 (non-overlapping)
  cond1_peaks <- cond1[-unique(queryHits(hits))]
  cond1_peaks <- clean_seqlevels(cond1_peaks)
  
  # Unique peaks for cond2 (non-overlapping)
  cond2_peaks <- cond2[-unique(subjectHits(hits))]
  cond2_peaks <- clean_seqlevels(cond2_peaks)
  
  # Return as named list
  return(list(common = common_peaks, peaks1 = cond1_peaks, peaks2 = cond2_peaks))
}

## Function to obtain peaks that overlap with promoters (±5 kb around the TSS)
overlap_proms <- function(peaks_orig){
  overlap_peaks <- peaks_orig[overlapsAny(peaks_orig, proms, type="within"),]
  # Rank by decreasing
  peaks_ranked <- overlap_peaks[order(mcols(overlap_peaks)$pValue, decreasing = TRUE)]
  # Take top N peaks, e.g. top 1000
  top_peaks <- peaks_ranked[1:1000]
  seqlevels(top_peaks) <- sub("^chr", "", seqlevels(top_peaks))
  seqs <- memes::get_sequence(top_peaks, twobit)

  return(seqs)
}


## Function to obtain and save motifs
obtain_motifs <- function(seqs, filename){
  res <- memes::runAme(seqs, database=convert_motifs(motifs), meme_path="/home/jesslyn/meme/bin")
  saveRDS(res, file=filename)
  return(res)
}

## Function to run motif enrichment analysis
motif_analysis_by_group <- function(cond1, cond2, filename_common, filename_cond1, filename_cond2){
  # Obtain common and unique peaks for the conditions
  peaks_results <- obtain_peaks(cond1, cond2)
  
  # Prepare the sequences
  common_seqs <- overlap_proms(peaks_results$common)
  cond1_seqs <- overlap_proms(peaks_results$peaks1)
  cond2_seqs <- overlap_proms(peaks_results$peaks2)
  
  # Motif enrichment analysis for each of the group
  ## Obtain motifs from final peaks (exact peak region)
  res_common <- obtain_motifs(common_seqs, filename_common)
  res_cond1 <- obtain_motifs(cond1_seqs, filename_cond1)
  res_cond2 <- obtain_motifs(cond2_seqs, filename_cond2)
}

## Function to visualize motifs
motif_visualization <- function(file_name, overlap_val=0.99){
  res <- readRDS(file_name)
  filtered_res <- res[res$adj.pvalue < 0.05, ]
  filtered_res<- filtered_res[order(filtered_res$adj.pvalue, decreasing = FALSE), ]
  universalmotif::view_motifs(motifs[filtered_res[1:10, ]$motif_id], 
                              min.overlap = overlap_val, 
                              RC.text = "", 
                              names.pos="right")
}
```

Load twobit data

```{r}
## To obtain twobit name
twobit_results <- AnnotationHub::query(ah, c("GRCm38", "twobit", "dna.primary_assembly"))

## Extract twobit files
twobit <- ah[["AH88475"]]
```

Motif preparation
```{r motif preparation}
## Pull only mouse HOCOMOCOv10, convert
motifs <- MotifDb::query(MotifDb, c("Mmusculus", "HOCOMOCOv10"))
motifs <- do.call(TFBSTools::PWMatrixList, setNames(
  universalmotif::convert_motifs(motifs, class="TFBSTools-PWMatrix"),
  mcols(motifs)$geneSymbol))
## Subset the motifs to only the high quality ones in the following way
motifNames <- unique(names(motifs))
motifs <- lapply(motifNames, function(motif){
  redundant_motifs <- motifs[names(motifs)==motif]
  ids <- unlist(lapply(redundant_motifs, function(m) m@ID))
  quality_rating <- unlist(tstrsplit(ids, split=".", keep=3, fixed=TRUE))
  motif <- redundant_motifs[[which(quality_rating==min(quality_rating))]]
  motif
})
names(motifs) <- motifNames
motifs <- do.call(PWMatrixList, motifs)
```

Define promoter regions (±5 kb around the TSS)
```{r}
txs <- keepSeqlevels(txs, common_seqlevels, pruning.mode = "coarse")
proms <- promoters(txs, upstream = 5000, downstream = 5000)
proms <- keepStandardChromosomes(proms, pruning.mode = "coarse")
```

Prepare peaks
```{r}
# Import peaks
## List the files:
peakfiles <- list.files("preprocessing/results/peaks", full.names = TRUE, recursive = TRUE)
peakfiles <- peakfiles[grepl("\\.narrowPeak$", peakfiles)]
## Give them meaningful names
names(peakfiles) <- gsub("_[^_]+\\..*$","",basename(peakfiles))
peaks <- lapply(peakfiles, FUN=rtracklayer::import, format="narrowPeak")
peaks <- lapply(peaks, clean_seqlevels)

ui_peaks <- do.call(c, list(peaks[["SRR14371953"]], peaks[["SRR14371954"]]))
i_peaks <- do.call(c, list(peaks[["SRR14371955"]], peaks[["SRR14371956"]], peaks[["SRR14371957"]]))
mdx_peaks <- do.call(c, list(peaks[["SRR15343189"]], peaks[["SRR15343190"]], peaks[["SRR15343191"]]))
wt_peaks <- do.call(c, list(peaks[["SRR15343192"]], peaks[["SRR15343193"]], peaks[["SRR15343194"]], peaks[["SRR15343195"]]))
```

Run motif enrichment analysis
```{r, eval=FALSE}
motif_analysis_by_group(mdx_peaks, wt_peaks, "mdx_wt_results.rds", "mdx_results.rds", "wt_results.rds")
motif_analysis_by_group(ui_peaks, i_peaks, "ui_i_results.rds", "ui_results.rds", "i_results.rds")
```

Visualize top 10 enriched motifs
```{r, fig.width=12, fig.height=10, dpi=150}
motif_visualization("motif_enrichment/motifs/mdx_wt_results.rds")
motif_visualization("motif_enrichment/motifs/mdx_results.rds")
motif_visualization("motif_enrichment/motifs/wt_results.rds")
motif_visualization("motif_enrichment/motifs/ui_i_results.rds")
motif_visualization("motif_enrichment/motifs/ui_results.rds")
motif_visualization("motif_enrichment/motifs/i_results.rds")
```

# Discussion

# References

# Appendix

## Session Information

```{r}
sessionInfo()
```
