---
title: "Bioinformatics Approaches to Regulatory Genomics and Epigenomics 2025 Project"
author: "Julia Frank, Jesslyn Jesslyn, Sara Leka"
date: "2025-06-24"
output: 
  html_document:
    code_folding: hide
    toc: true          # include TOC
    toc_float: true    # makes the TOC float as a sidebar
    toc_depth: 4       # how many heading levels to include (1, 2, 3...)
bibliography: project_references.bib
link-citations: TRUE 
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

Myofibers are the main structural and functional units of skeletal muscle. They are highly adaptive cells that vary widely in size, metabolic activity, and functional properties. This adaptability is reflected in their transcriptomic and epigenomic landscapes, which can shift significantly in response to physiological and pathological conditions. Understanding these regulatory changes offers insights into how skeletal muscle adapts, regenerates, and deteriorates under different conditions.

In this context, ATAC-seq data is a powerful tool to study chromatin accessibility. When applied to single myofibers, this technique provides sufficient resolution and depth for downstream epigenetic analysis without the presence of confounding muscle resident cell types. This approach was conducted in the study "Application of ATAC-Seq for genome-wide analysis of the chromatin state at single myofiber resolution" by [@sahinyan2022atac]. In their work, they used single-myofiber ATAC-seq (smfATAC-seq) to profile chromatin accessibility in myofibers under various physiological and disease conditions.\
The aim of our project is to reproduce and critically evaluate key aspects of that study. We focus on two biologically relevant comparisons: uninjured (UI) vs. injured (I) myofibers, and wild-type (WT) vs. dystrophic (MDX) myofibers. The UI vs. I comparison allows us to explore how myofibers change their chromatin landscape during regeneration following cardiotoxin-induced injury. The WT vs. MDX comparison highlights the epigenomic consequences of Duchenne Muscular Dystrophy (DMD), for which the MDX mouse serves as a widely used model.

Our pipeline covers the full pre-processing of raw ATAC-seq data, including quality control, alignment, filtering, peak calling, and normalization. We then assess data quality and consistency through correlation analysis, followed by differential accessibility analysis, gene set enrichment analysis and motif discovery to interpret the biological significance of the observed changes.

# Methods & Results

## Load packages

At first, all necessary packages were installed and loaded. Information on the package versions used can be found in the Appendix.

```{r load packages}
suppressPackageStartupMessages({
  library(GenomicRanges)
  library(rtracklayer)
  library(epiwraps)
  library(AnnotationHub)
  library(ensembldb)
  library(ggplot2)
  library(tidyverse)
  library(DESeq2)
  library(pheatmap)
  library(RColorBrewer)
  library(pheatmap)
  library(gridExtra)
  library(ggpubr)
  library(grid)
  library(limma)
  library(edgeR)
  library(MotifDb)
  library(universalmotif)
  library(data.table)
  library(TFBSTools)
  library(Biostrings)
  library(ggrepel)
  library(patchwork)
  library(yaml)
  library(org.Mm.eg.db)
  library(rGREAT)
})
```

## The Data

The pipeline processes single myofiber ATAC-seq data obtained from the Extensor Digitorum Longus (EDL) muscle of *Mus musculus*. The raw data is available through the [SRA Run Selector](https://www.ncbi.nlm.nih.gov/Traces/study/?acc=PRJNA726576&o=acc_s%3Aa) (SRA accession numbers used are listed in Supplementary Table 1) and the authors also provide their processed coverage tracks on [GEO](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE173676) (GEO accession number GSE173676).

The dataset consists of two distinct and independently conducted experiments, each addressing a separate biological question. The first experiment investigates muscle regeneration by comparing uninjured and injured myofibers. The second focuses on muscular dystrophy by comparing wild-type (WT) and MDX mice, a model for Duchenne Muscular Dystrophy (DMD). These two experiments were performed on different days and used different mouse strains, both of which can introduce batch effects.

Because these batch effects are strongly confounded with the biological conditions (i.e., all WT and MDX samples belong to one batch, and all injured and uninjured samples to another), a joint analysis across all four conditions would not allow us to confidently separate technical variation from true biological differences. To avoid this confounding and ensure meaningful interpretation, we analyzed the two experiments separately.

**Experiment 1 – Muscle Regeneration (2021-05-01)**\
*Mouse strain: C57BL/6*

-   Uninjured_1–2: 2 uninjured control myofibers

-   Injured_1–3: 3 injured myofibers (collected 7 days after acute injury, representing the regenerating state)

**Experiment 2 – Muscular Dystrophy (2021-08-07)**\
*Mouse strain: C57/B10ScSn-Dmdmdx & C57/B10ScSn*

-   MDX_1–3: 3 myofibers from MDX mice (a DMD model with chronic muscle degeneration)

-   WT_1–4: 4 myofibers from wild-type healthy control mice

## Preprocessing

In order to generate all the data needed downstream (peaks, counts, coverage tracks), we processed the raw data. Since preprocessing is quite computationally and memory intensive, we performed it on Euler. All code scripts and resulting data are available in the `preprocessing` folder. The coverage tracks were too large for GitHub, so we uploaded them to [OneDrive](https://1drv.ms/f/c/ad47ab1cb526b6da/EiGJACKkCqhAqehU3_HI-AMBXvwKSJhkNprIwYIos2Fupg?e=tbCstp). If you want to rerun the R script, please download the coverage tracks and place them in `preprocessing`\>`results`\>`tracks`.

### 1. Trimming

Raw `.sra` files were converted to `.fastq.gz`, followed by adapter trimming using the `trimmomatic` package. Specifically, Illumina NexteraPE-PE adapters were removed. Quality control was performed both before and after trimming using `FastQC` and summarized with `MultiQC`.

### 2. Alignment

Trimmed reads were aligned to the mm10 mouse genome using `bowtie2`, followed by filtering, sorting, and indexing with `samtools`. Only uniquely mapping reads were retained. The `.bam` files were then filtered for high-quality, uniquely mapped reads (MAPQ ≥ 20), and PCR duplicates were marked using `Picard`. Read groups were added to comply with downstream processing tools. Final sorting and indexing was performed with `samtools`.

```{r, echo=FALSE, out.width="80%", fig.align='center'}
knitr::include_graphics("images/alignment_stats.png")
```

*Fig. 1: The horizontal bar plot shows the number of reads that mapped uniquely, mapped to multiple locations, or did not map at all for each sample.*

Many reads map to multiple genomic regions, which reduces the number of uniquely aligned reads retained for downstream analysis. As a result, the average unique mapping rate of around 50% is quite low.

### 3. Peak Calling

Peaks were called using `MACS3` on each individual `.bam` file, generating `.narrowPeak` files representing regions of open chromatin.

### 4. Count Matrix Generation

To compare chromatin accessibility between conditions, we first combined the peak files from all replicates of each experiment (UI vs. I and WT vs. MDX). We then merged overlapping peaks to create a consensus peak set for each comparison. These consensus peaks represent regions that were accessible in at least one of the samples. Next, we counted how many reads from each sample overlapped with each consensus peak to create a count matrix.

### 6. Coverage Track Generation

For visualization and downstream analyses, normalized bigWig coverage tracks were generated using `bamCoverage` from the `deepTools` suite.

### 7. Condition Specific Peak Calling

To define reproducible peaks for each condition, we used ENCODE's "naive overlap" approach [@hitzENCODEUniformAnalysis2023] . First, we merged the aligned reads from all replicates per condition and called peaks on the pooled data. We then retained only those pooled peaks that overlapped by ≥50 % of their length with peaks from replicates. This filtering step ensures that downstream motif enrichment is based on robust, reproducible peak regions.

### 8. Load the Preprocessed Data

For the subsequent analysis, we load the merged coverage tracks and count matrices from both experiments into this R Markdown document.

```{r load data}
# Change the ouput size to look nicer
options(width = 150)

# Define folder structure
tracks_path <-"preprocessing/results/tracks"
mat_path <-"preprocessing/results/count_matrix"

# Load the merged coverage tracks for all experimental conditions
tracks <- list(
  Uninjured=paste0(tracks_path, "/uninjured_merged.bw"),
  Injured=paste0(tracks_path, "/injured_merged.bw"),
  WT=paste0(tracks_path, "/wt_merged.bw"),
  MDX=paste0(tracks_path, "/mdx_merged.bw")
)

# Define the sample names
names1 <- c("Uninjured_1", "Uninjured_2", "Injured_1", "Injured_2", "Injured_3")
names2 <- c("MDX_1", "MDX_2", "MDX_3", "WT_1", "WT_2", "WT_3", "WT_4")

# Read in the data table, skipping the first comment lines
counts1 <- read.delim(paste0(mat_path, "/counts_UI_I.txt"), comment.char="#", stringsAsFactors=FALSE)
counts2 <- read.delim(paste0(mat_path, "/counts_MDX_WT.txt"), comment.char="#", stringsAsFactors=FALSE)

# Rename the columns
colnames(counts1)[7:ncol(counts1)] <- names1
colnames(counts2)[7:ncol(counts2)] <- names2

# Set rownames to peak ID
rownames(counts1) <- counts1$Geneid
counts1$Geneid <- NULL
rownames(counts2) <- counts2$Geneid
counts2$Geneid <- NULL

# Load the peak files
peakfiles <- list.files("preprocessing/results/peaks", full.names = TRUE)
peaks_bed <- peakfiles[grepl("consensus.*\\.bed$", peakfiles)]
names(peaks_bed) <- sub("\\.bed$", "", basename(peaks_bed))
peaks_bed <- lapply(peaks_bed, FUN=rtracklayer::import, format="bed")

peaks_narrow <- peakfiles[grepl("final.*\\.narrowPeak$", peakfiles)]
names(peaks_narrow) <- gsub("_[^_]+\\..*$","",basename(peaks_narrow))
peaks_narrow <- lapply(peaks_narrow, FUN=rtracklayer::import, format="narrowPeak")


# Look at the data
#cat("First few rows of the count matrix for uninjured vs. injured samples:\n")
#head(counts1)
#cat("First few rows of the count matrix for MDX vs. WT samples:\n")
#head(counts2)
```

## Data Validation

We plotted the enrichment of ATAC-seq signal around transcription start sites (TSSs) to assess data quality and validate that our assay accurately captured regions of open chromatin. Since TSSs are typically located in accessible, nucleosome-depleted regions of active genes, we expected to observe strong signal enrichment at these sites.

```{r TSS enrichment, fig.align='center'}
# 1. Load the Ensembl Transcript Database for mouse
ah <- AnnotationHub()

# 2. Search for relevant datasets
# Note: GRCm38 is the same genome assembly as mm10 used for alignment
# We use the Ensembl annotation, even though our reference genome is from UCSC, because we want to filter by biotype
q <- AnnotationHub::query(ah, c("Mus musculus", "EnsDb", "GRCm38"))

# 3. Retrieve metadata for all available versions
meta <- mcols(q)[, c("rdatadateadded", "title", "genome", "tags", "rdatapath")]

# 4. Select the newest version
ensdb <- ah[["AH83247"]]

# 5. Load transcripts (protein-coding only)
txs <- transcripts(ensdb, filter = TxBiotypeFilter("protein_coding"))

# 6. Fix chromosome naming by adding 'chr' prefix where appropriate
seqlevels(txs) <- ifelse(seqlevels(txs) %in% c(as.character(1:19), "X", "Y", "MT"),
                        paste0("chr", seqlevels(txs)),
                        seqlevels(txs))

# 7. Keep only chromosomes shared between annotation and BigWig files
bw_seqinfo <- seqinfo(BigWigFile(tracks[[1]]))
common_seqlevels <- intersect(seqlevels(txs), seqlevels(bw_seqinfo))
txs <- keepSeqlevels(txs, common_seqlevels, pruning.mode = "coarse")

# 8. Get transcription start site (TSS) positions
tss <- GenomicRanges::reduce(promoters(txs, upstream = 0, downstream = 1))

# 9. Compute signal matrix around TSS
tss_matrix <- epiwraps::signal2Matrix(tracks, granges(tss), w = 10, extend = 1000)
title <- " Enrichment at Transcription Start Site (TSS)"

# 10. Plot heatmap of the enrichment signals
hm <- epiwraps::plotEnrichedHeatmaps(tss_matrix, trim = 0.95, colors = c("white", "darkred"), 
                                    multiScale = TRUE, axis_name = "TSS")
draw(hm, column_title = title)
```

*Fig. 2: Heatmap showing the ATAC-seq signal around the transcription start sites (TSS) of uninjured, injured, WT, and MDX myofibers.*

The heatmap shows a clear enrichment of ATAC-seq signal at transcription start sites, indicating that chromatin accessibility is highest near gene promoters. This pattern confirms the expected biological behavior, where regulatory elements around the TSS are more open and accessible for transcription machinery binding. The slight upstream shift of the peaks suggests that many transcription factors preferentially bind just before the TSS.

## Replicate Comparison and Clustering

### Normalization

The raw count data was then normalized using the regularized log (rlog) transformation from the `DESeq2` [@loveModeratedEstimationFold2014] package, which stabilizes variance across samples, especially for genes with low counts.

```{r normalization}
# Function to normalize count data using rlog transformation from DESeq2
process_mat <- function(mat) {
  # Extract count columns starting from the 6th column onward (rest is meta data)
  count_data <- mat[, 6:ncol(mat)]
  
  # Convert count data to a numeric matrix
  count_data <- as.matrix(count_data)
  mode(count_data) <- "numeric"
  
  # Construct a DESeq2 dataset object without any experimental design
  dds <- DESeqDataSetFromMatrix(
    countData = count_data,
    colData = DataFrame(row.names = colnames(count_data)),
    design = ~1  # No experimental grouping; used for transformation only
  )
  
  # Apply rlog transformation (variance-stabilizing, blind to design)
  rlog_counts <- rlog(dds, blind = TRUE)
  
  # Extract the transformed (normalized) count matrix
  norm_mat <- assay(rlog_counts)
  
  # Replace any NA values with 0
  norm_mat[is.na(norm_mat)] <- 0
  
  return(norm_mat)
}

# Normalize counts for the "Uninjured vs. Injured" experiment
norm_counts1 <- process_mat(counts1)
#cat("First few rows of the normalized count matrix for uninjured vs. injured samples:\n")
#head(norm_counts1)

# Normalize counts for the "MDX vs. WT" experiment
norm_counts2 <- process_mat(counts2)
#cat("First few rows of the normalized count matrix for MDX vs. WT samples:\n")
#head(norm_counts2)
```

### Pearson Correlation Heatmaps

Pearson correlation heatmaps were generated from the normalized count data to evaluate the similarity between replicates within each experimental condition.

```{r correlation heatmap, fig.align='center'}
# PEARSON CORRELATION HEATMAPS

# Compute Pearson correlation matrices for normalized counts
cor_mat1 <- cor(norm_counts1, method = "pearson")
cor_mat2 <- cor(norm_counts2, method = "pearson")

# Define cell size for consistent heatmap appearance
cell_size <- 24

# Generate heatmap for the Uninjured vs. Injured comparison
hm1 <- pheatmap(
  cor_mat1,
  cluster_rows = FALSE,
  cluster_cols = FALSE,
  main = "Uninjured vs. Injured",
  col = colorRampPalette(brewer.pal(9, "Blues"))(100),
  silent = TRUE,
  cellwidth = cell_size,
  cellheight = cell_size
)

# Generate heatmap for the MDX vs. WT comparison
hm2 <- pheatmap(
  cor_mat2,
  cluster_rows = FALSE,
  cluster_cols = FALSE,
  main = "MDX vs. WT",
  col = colorRampPalette(brewer.pal(9, "Blues"))(100),
  silent = TRUE,
  cellwidth = cell_size,
  cellheight = cell_size
)

# Arrange both heatmaps side by side in a single figure
grid.arrange(
  grobs = list(hm1$gtable, hm2$gtable),
  ncol = 2,
  widths = c(1, 1),
  top = textGrob("Pearson correlation between replicates", gp = gpar(fontsize = 16, fontface = "bold"))
)

```

*Fig. 3: Heatmaps of Pearson correlation coefficients based on normalized ATAC-seq counts, illustrating the correlation between replicates in the Uninjured vs. Injured comparison (left) and the WT vs. MDX comparison (right).*

Overall, the Pearson correlation is very high for all samples, with correlation coefficients consistently above 0.95 regardless of condition. In the Uninjured vs. Injured experiment, the injured replicates clearly cluster more closely together than with the uninjured ones. However, the uninjured replicates appear more similar to the injured samples than to the other uninjured replicate. For the MDX vs. WT experiment, there is no clear difference in correlation between replicates of the same condition compared to samples from the other condition.

### Principal Component Analysis (PCA)

Next, we performed a Principal Component Analysis to visualize how close the samples cluster together.

```{r pca, fig.width=10, fig.height=5, fig.align='center'}
# PCA

# Function to extract condition based on the sample name
get_conditions <- function(colnames_vec) {
  substr(colnames_vec, 1, nchar(colnames_vec) - 2)
}

# Function to generate PCA plot
plot_pca <- function(norm_signal, subtitle_text) {
  sample_names <- colnames(norm_signal)
  sample_conditions <- get_conditions(sample_names)
  
  # Perform PCA on transposed data (samples as rows)
  pca <- prcomp(t(norm_signal), scale. = FALSE)
  
  # Calculate percentage of variance explained by PC1 and PC2
  var_explained <- round((pca$sdev^2 / sum(pca$sdev^2))[1:2] * 100, 1)
  
  # Create data frame for ggplot input
  pca_df <- data.frame(
    PC1 = pca$x[,1],
    PC2 = pca$x[,2],
    Sample = sample_names,
    Condition = sample_conditions
  )
  
  # Create PCA scatter plot with labels and styling
  ggplot(pca_df, aes(PC1, PC2, color = Condition, label = Sample)) +
    geom_point(size = 4) +                           
    geom_text(vjust = -1, hjust = 0.5, size = 5) +  
    coord_cartesian(clip = "off") +                
    theme_minimal(base_size = 20) +                 
    labs(
      x = paste0("PC1 (", var_explained[1], "% variance)"),
      y = paste0("PC2 (", var_explained[2], "% variance)"),
      subtitle = subtitle_text                      
    ) +
    theme(
      plot.subtitle = element_text(size = 20, hjust = 0.5, face = "bold"),
      legend.position = "bottom",
      legend.text = element_text(size = 14),
      legend.title = element_text(size = 16),
      legend.key.size = unit(0.6, "cm"),
      axis.title = element_text(size = 18),
      axis.text = element_text(size = 14),
      plot.margin = margin(10, 10, 10, 10)           
    )
}

# Generate individual PCA plots for both datasets
pca_plot1 <- plot_pca(norm_counts1, "Uninjured vs. Injured")
pca_plot2 <- plot_pca(norm_counts2, "MDX vs. WT")

# Combine the two plots side-by-side 
final_plot <- ggarrange(
  pca_plot1, pca_plot2,
  ncol = 2, nrow = 1,
  common.legend = FALSE
)

# Add an overall title above the combined figure
annotate_figure(
  final_plot,
  top = text_grob("PCA of Samples", face = "bold", size = 24, hjust = 0.5)
)

```

*Fig. 4: Principal component analysis (PCA) plot showing samples along the first two principal components for Uninjured vs. Injured (left) and MDX vs. WT (right).*

In the PCA plots, samples clearly separate based on their experimental conditions, indicating distinct chromatin accessibility profiles.

### Hierarchical Clustering between Replicates

Hierarchical clustering was performed on normalized accessibility signals to assess the similarity between biological replicates.

```{r hierarchical clustering, fig.width=8, fig.height=4,  fig.align='center'}
# HIERARCHICAL CLUSTERING

# Function to perform hierarchical clustering and plot dendrogram 
plot_hclust <- function(norm_signal, plot_title) {
  # Calculate distance matrix between samples (columns)
  dist_mat <- dist(t(norm_signal))
  
  # Perform hierarchical clustering on the distance matrix
  hc <- hclust(dist_mat)
  
  # Plot the dendrogram
  plot(hc, main = plot_title, xlab = "", sub = "", cex = 0.8, font.main = 1) 
}

# Set up plotting area to have 1 row and 2 columns for side-by-side plots
# Adjust outer margins (oma) to provide space for the overall title above both plots
# Adjust inner margins (mar) to fit axis labels and titles nicely
par(mfrow = c(1, 2), oma = c(1, 1, 2.2, 1), mar = c(4, 4, 1, 1))

# Generate hierarchical clustering dendrograms for both datasets
hc1 <- plot_hclust(norm_counts1, "Uninjured vs. Injured")
hc2 <- plot_hclust(norm_counts2, "MDX vs. WT")

# Add a main title above the two plots
mtext("Hierarchical Clustering of Samples", side = 3, outer = TRUE, line = 1, cex = 1.5)

# Reset plotting parameters to default (single plot, no outer margin adjustments)
par(mfrow = c(1, 1), oma = c(0, 0, 0, 0))

```

*Fig. 5: Hierarchical clustering dendrograms of normalized ATAC-seq counts showing sample relationships for Uninjured vs. Injured (left) and MDX vs. WT (right) conditions.*

As noted in the Pearson Correlation Heatmaps, the injured replicates cluster tightly together, while the uninjured replicates do not cluster as closely with each other and instead appear closer to the injured samples. In the MDX vs. WT comparison, replicates do not consistently cluster together by condition.

## Differential Accessibility Analysis

Differential accessibility analysis was performed using `DESeq2` [@loveModeratedEstimationFold2014], where counts from each experiment were compared by setting one condition as the baseline (Uninjured or WT) and testing for differences in accessibility against the contrasting condition (Injured or MDX).

```{r differential accessibility analysis}
# Function to run the differential accessibility analysis
run_deseq2 <- function(count_mat, baseline_condition, contrast_condition, name = "") {
  # 1. Convert to numeric matrix
  count_data <- as.matrix(count_mat)
  mode(count_data) <- "numeric"
  
  # 2. Extract condition from column names (e.g., "WT_1", "WT_2")
  condition <- substr(colnames(count_data), 1, nchar(colnames(count_data)) - 2)
  
  # 3. Set up condition factor and relevel
  condition <- factor(condition)
  condition <- relevel(condition, ref = baseline_condition)
  
  # 4. Create metadata
  metadata <- data.frame(row.names = colnames(count_data), condition = condition)
  
  # 5. Create DESeqDataSet
  dds <- DESeqDataSetFromMatrix(countData = count_data,
                                colData = metadata,
                                design = ~ condition)
  
  # 6. Filter lowly accessible peaks
  dds <- dds[rowSums(counts(dds)) >= 1, ]
  
  # 7. Run DESeq2
  dds <- DESeq(dds)
  
  # 8. Extract results for contrast
  res <- results(dds, contrast = c("condition", contrast_condition, baseline_condition))
  res_df <- as.data.frame(res)
  res_df$peak <- rownames(res_df)
  res_df$logFC <- res$log2FoldChange
  res_df$pvalue <- res$pvalue
  res_df$method <- name
  
  # 9. Remove rows with missing values
  res_df <- na.omit(res_df)
  
  # 10. Adjust p-values and clip them
  res_df$padj <- p.adjust(res_df$pvalue, method = "BH")
  
  # Clip p-value of one particularly high outlier to reduce visual distortion
  res_df$padj <- ifelse(res_df$padj < 1e-10, 1e-10, res_df$padj)
  
  # 11. Mark significant genes
  res_df$significant <- ifelse(abs(res_df$logFC) > 1 & res_df$padj < 0.05, "Significant", "Not Significant")
  
  return(res_df)
}

# Experiment 1 - Uninjured vs. Injured: baseline = "Uninjured"
res1 <- run_deseq2(counts1[, 6:ncol(counts1)], baseline_condition = "Uninjured", contrast_condition = "Injured", name = "Uninjured vs. Injured")

# Experiment 2 - WT vs. MDX: baseline = "WT"
res2 <- run_deseq2(counts2[, 6:ncol(counts2)], baseline_condition = "WT", contrast_condition = "MDX", name = "WT vs. MDX")

# Get significant peak IDs
significant_peaks1 <- rownames(res1[res1$significant == "Significant", ])
significant_peaks2 <- rownames(res2[res2$significant == "Significant", ])

# Print summary message
cat("DESeq2 identified", length(significant_peaks1), "significantly differentially accessible regions (FDR < 0.05 and |LFC| ≥ 1) between uninjured and injured myofibers, and", length(significant_peaks2), "significantly differentially accessible regions between WT and MDX.\n")
```

Next, peaks were annotated by mapping them to the nearest genes using `UCSC mm10` annotations from `AnnotationHub`. For each peak, the closest gene, its Entrez ID, gene symbol, and distance to the peak were identified.

```{r annotation}
# Query for UCSC annotations for mouse
# Note this time we didn't need the biotype, so we used the matching UCSC annotations
q <- AnnotationHub::query(ah, c("Mus musculus", "UCSC", "mm10", "TxDb"))

# Retrieve metadata for all available versions
meta <- mcols(q)[, c("rdatadateadded", "title", "genome", "tags", "rdatapath")]

# Select the newest version
txdb <- ah[["AH75762"]]

# Function to annotate our peaks (distance to closest gene & its name/Id)
annotate <- function(counts) {
  # 1. Retrieve all genes, including those spanning multiple strands or chromosomes
  genes_gr <- unlist(genes(txdb, single.strand.genes.only = FALSE))
  
  # 2. Convert peak coordinates in counts data frame to GRanges object
  peak_gr <- GRanges(
    seqnames = counts$Chr,
    ranges = IRanges(start = counts$Start, end = counts$End),
    strand = "*"
  )
  
  # 3. Find nearest gene indices for filtered peaks (may contain NAs)
  nearest_genes_idx <- nearest(peak_gr, genes_gr)
  
  # 4. Create the output data frame, starting from counts and adding columns
  annotated_counts <- counts
  annotated_counts[, c("nearest_gene", "gene_id", "distance_to_gene", 
                       "annotation")] <- NA
  annotated_counts$peak <- rownames(counts)

  # 5. Process only peaks that have a nearest gene assigned
  valid <- !is.na(nearest_genes_idx)
  
  nearest_idx_valid <- nearest_genes_idx[valid]
  peak_idx_valid <- which(valid)   # Fix: use which() here instead of keep_idx
  
  nearest_genes <- genes_gr[nearest_idx_valid]
  distances <- distance(peak_gr[peak_idx_valid], nearest_genes)
  
  # 6. Extract Entrez gene IDs from nearest genes
  gene_ids <- names(nearest_genes)
  
  # 7. Map Entrez IDs to gene symbols (names)
  gene_symbols <- mapIds(org.Mm.eg.db,
                         keys = gene_ids,
                         column = "SYMBOL",
                         keytype = "ENTREZID",
                         multiVals = "first")
  
  # 8. Fill in annotations into the data frame
  annotated_counts$nearest_gene[peak_idx_valid] <- gene_symbols
  annotated_counts$nearest_gene[peak_idx_valid] <- gene_symbols
  annotated_counts$gene_id[peak_idx_valid] <- gene_ids
  annotated_counts$distance_to_gene[peak_idx_valid] <- distances
  annotated_counts$annotation[peak_idx_valid] <- ifelse(
    distances >= 0,
    paste0(gene_symbols, "+", distances, " bp"),
    paste0(gene_symbols, distances, " bp")
  )
  
  return(annotated_counts)
}

# Annotate the count matrices
counts1_ann = annotate(counts1)
counts2_ann = annotate(counts2)

# Merge the annotations to the results
res1_ann <- merge(res1, counts1_ann[, c("peak", "Chr", "Start", "End", "nearest_gene", "gene_id", "distance_to_gene","annotation")], by = "peak", all.x = TRUE)
res2_ann <- merge(res2, counts2_ann[, c("peak", "Chr", "Start", "End", "nearest_gene", "gene_id", "distance_to_gene","annotation")], by = "peak", all.x = TRUE)

# Combine the annotated significant results
combined_res <- rbind(res1_ann, res2_ann)

# Select top 6 by significance (lowest padj) per method
top6_annotated <- combined_res %>%
  filter(!is.na(padj)) %>%
  arrange(padj) %>%
  group_by(method) %>%
  slice_head(n = 6) %>%
  ungroup()

# Print summary message
cat("Nearest genes were assigned to", sum(!is.na(combined_res$gene_id)), "peaks. For", sum(is.na(combined_res$nearest_gene)) - sum(is.na(combined_res$gene_id)),
"peaks, only a gene ID is available without a corresponding gene name.",
sum(is.na(combined_res$annotation)), "peaks remain unannotated.\n")

```

The differential accessibility results were visualized using volcano plots, displaying log2 fold changes against the FDR-adjusted p-values. Significant peaks were highlighted, and the top annotated peaks were labeled for clearer interpretation.

```{r volcano plot, fig.align='center'}
# Create volcano plot with annotation labels
volcano_combined <- ggplot(combined_res, aes(x = logFC, y = -log10(padj))) +
  geom_point(aes(color = significant), alpha = 0.7, size = 1) +
  scale_color_manual(values = c("gray", "maroon")) +
  facet_wrap(~ method, ncol = 2) +
  theme_minimal() +
  labs(
    title = "Volcano Plots",
    x = "Log2 Fold Change",
    y = "-Log10 (FDR corrected p-value)"
  ) + 
  theme(
    plot.title = element_text(hjust = 0.5),
    strip.text = element_text(size = 12)
  ) +
  geom_text_repel(
    data = top6_annotated,
    aes(label = annotation),
    color = "maroon",
    size = 3,
    max.overlaps = Inf,          # show all selected labels
    box.padding = 0.5,           # more space around label
    point.padding = 0.8,         # more space around the point
    force = 2,                   # increase repulsion
    force_pull = 0.3,            # gentle pull back to point
    nudge_y = 0.2,
    segment.size = 0.3,
    segment.color = "gray",
    min.segment.length = 0.2,    # avoid short segments
    direction = "both",          # free movement
    seed = 42
  )

print(volcano_combined)
```

*Fig. 6: Volcano plots of differential chromatin accessibility between conditions for Uninjured vs. Injured (left) and WT vs. MDX (right). Points represent peaks colored by significance, with top significant peaks labeled by their nearest gene and distance to that gene.*

The volcano plot comparing Uninjured vs. Injured samples shows much larger log-fold changes, indicating stronger shifts in accessibility for individual regions. In contrast, the WT vs. MDX comparison reveals a higher number of significantly differentially accessible regions overall, despite generally smaller fold changes.

One gene, Rftn1, stood out in the WT vs. MDX comparison with extremely high upregulation in MDX relative to WT and showed statistical significance. Its p-value was clipped in the plot to maintain visual clarity. Such genes, which exhibit both strong effect size and high significance, could be of interest for follow-up studies.

Interestingly, for the Uninjured vs. Injured comparison, the annotated differentially accessible regions in our volcano plot differ entirely from those highlighted in the paper, suggesting potential differences in methods.

## Gene Set Enrichment Analysis

Gene set enrichment was carried out with `GREAT`[@guRGREATBioconductorPackage2023] using MSigDB Hallmark gene sets [@castanzaExtendingSupportMouse2023] on significant differentially accessible regions (DARs). Instead of using a ranked gene list as in the original paper, we worked directly with genomic intervals to answer the question: *Which hallmark pathways are overrepresented among regions that gain or lose accessibility between conditions?* To address this, we ran `GREAT` separately on up‑ and down‑regulated DARs (injured compared to uninjured myofibers and MDX compared to WT myofibers), using the union of all consensus peaks for each pair of conditions as our background.

```{r enrichment analysis, fig.width=15, fig.height=8, dpi=150, fig.align='center', fig.show='hold'}
# Load MSigDB Hallmark gene sets for subsequent enrichment analysis
hallmark_list <- read_gmt("mh.all.v2025.1.Mm.entrez.gmt", from = 'ENTREZ', to   = 'ENTREZ')

# Function to extract upregulated and downregulated DARs in GRange
dars_gr <- function(dars, consensus_peak){
  # Convert consensus peak into dataframe
  consensus_peaks <- as.data.frame(consensus_peak)
  consensus_peaks$peak <- paste0("peak", seq_len(nrow(consensus_peaks)))

  # Assign chr, start and end to DARs
  dars <- merge(dars, consensus_peaks[, c("peak", "seqnames", "start", "end")], by = "peak", all.x = TRUE)

  # Convert DARs dataframe into GRange
  dars <- makeGRangesFromDataFrame(dars,
                                   keep.extra.columns = TRUE,
                                   ignore.strand = TRUE)

  # Extract upregulated DARs
  dars_up <- dars[dars$logFC > 0]
  # Extract downreguated DARs
  dars_down <- dars[dars$logFC < 0]
  
  return(list(up = dars_up, down = dars_down))
}

# Function to run great on DARs
run_great <- function(dars_gr, consensus_peak){
  res <- great(dars_gr, gene_sets=hallmark_list, 
               tss_source="mm10", 
               background=consensus_peak, cores=4)
  hm <- getEnrichmentTables(res, min_region_hits = 2)
  
  # Sort great results in decreasing enrichment order
  hm <- hm[order(hm$fold_enrichment, decreasing = TRUE),]
  
  return(hm)
}

# Function to clean yaxis label
clean_label <- function(x) {
  x %>%
    str_remove("^HALLMARK_")
}

plot_formatting <- list(xlab("Fold enrichment"),
                        ylab("MSigDB Hallmark Gene Sets"),
                        scale_y_discrete(labels = clean_label),
                        theme(
                          axis.text.y = element_text(size = 12),
                          axis.text.x = element_text(size = 12),
                          plot.title = element_text(size = 16),
                          axis.title.x = element_text(size = 14),
                          axis.title.y = element_text(size = 14),
                          legend.title = element_text(size = 14),
                          legend.text = element_text(size = 12)))

# Plot enrichment analysis
plot_enrichment <- function(hm_up, hm_down){
  p1 <- ggplot(head(hm_up,10), aes(fold_enrichment, reorder(id, fold_enrichment), 
                        size=observed_region_hits, color=-log10(p_adjust))) + 
    geom_point() + scale_color_viridis_c() +
    ggtitle("(a) Upregulated pathways") +
    plot_formatting
    
  p2 <- ggplot(head(hm_down,10), aes(fold_enrichment, reorder(id, fold_enrichment), size=observed_region_hits, color=-log10(p_adjust))) + 
    geom_point() + scale_color_viridis_c() +
    ggtitle("(b) Downregulated pathways") +
    plot_formatting

  combined <- p1 + p2 + plot_layout(ncol = 2)
  return(combined)
}

# Function to run full gsea
gsea <- function(dars, consensus_peak){
  dars1 <- dars_gr(dars, consensus_peak)
  dars_up <- dars1$up
  dars_down <- dars1$down
  
  hm_up <- run_great(dars_up, consensus_peak)
  hm_down <- run_great(dars_down, consensus_peak)
  
  combine_plot <- plot_enrichment(hm_up, hm_down)
  return(combine_plot)
}

gsea(res1[(res1$significant == 'Significant'),], peaks_bed$consensus_peaks_UI_I)
```

*Fig. 7: Enrichment analysis of differentially accessible regions (DARs) between uninjured and injured myofibers, using consensus peaks as background. Shown are (a) pathways enriched in regions with increased accessibility (upregulated DARs) and (b) pathways enriched in regions with decreased accessibility (downregulated DARs) in injured relative to uninjured myofibers.*

```{r enrichment mdx_wt, fig.width=15, fig.height=8, dpi=150, fig.align='center', fig.show='hold'}
gsea(res2[(res2$significant == 'Significant'),], peaks_bed$consensus_peaks_MDX_WT)
```

*Fig. 8: Enrichment analysis of differentially accessible regions (DARs) between WT and MDX myofibers, using consensus peaks as background. Shown are (a) pathways enriched in regions with increased accessibility (upregulated DARs) and (b) pathways enriched in regions with decreased accessibility (downregulated DARs) in MDX relative to WT myofibers.*

As expected, given our region-centric enrichment approach rather than the paper's ranked genes method, the order of enriched pathways differs. Nonetheless, we still observe key inflammatory and injury related pathways (e.g. IL6–JAK–STAT3 [@zhangInterleukin6SignalTransducer2013], Complement activation [@yangSkeletalMuscleRegeneration2018]) among the top 10 upregulated pathways in injured against uninjured myofibers, consistent with the original findings (Fig. 7).

Similarly, in MDX against WT myofibers (Fig. 8), we observed highly ranked pathways, such as IL6–JAK–STAT3 [@zhangInterleukin6SignalTransducer2013] and wnt/β-Catenin [@liuActivationWntVCatenin2016], that have been previously reported as upregulated in Duchenne’s muscular dystrophy (DMD).

Overall, even though we adopted a region-centric enrichment approach, we still identify key inflammatory and injury related pathways, validating the use of `great` for GSEA.

## Motif Enrichment Analysis

We performed motif enrichment analysis to identify top motifs that are enriched in peaks around the promoter regions. This was performed with the following steps:

1.  Motif preparation

    ```{r motif preparation}
    # 1. Pull only mouse HOCOMOCOv10, convert
    motifs <- MotifDb::query(MotifDb, c("Mmusculus", "HOCOMOCOv10"))
    motifs <- do.call(TFBSTools::PWMatrixList, setNames(
      universalmotif::convert_motifs(motifs, class="TFBSTools-PWMatrix"),
      mcols(motifs)$geneSymbol))

    # 2. Subset the motifs to only the high quality ones
    motifNames <- unique(names(motifs))
    motifs <- lapply(motifNames, function(motif){
      redundant_motifs <- motifs[names(motifs)==motif]
      ids <- unlist(lapply(redundant_motifs, function(m) m@ID))
      quality_rating <- unlist(tstrsplit(ids, split=".", keep=3, fixed=TRUE))
      motif <- redundant_motifs[[which(quality_rating==min(quality_rating))]]
      motif
    })

    # 3. Convert motifs into the required format
    names(motifs) <- motifNames
    motifs <- do.call(PWMatrixList, motifs)
    ```

2.  Define promoter regions

    The promoter regions were defined as ±5 kb around the TSS to keep it consistent with the paper.

    ```{r promoter regions}
    proms <- promoters(tss, upstream = 5000, downstream = 5000)
    proms <- keepStandardChromosomes(proms, pruning.mode = "coarse")
    ```

3.  Prepare peaks

    Next, we prepared the set of peaks that are common and unique between two conditions as defined in Table 1.

    +-------------------------------------------------+--------------------------------------+
    | Group 1 (Uninjured and injured Myofibers)       | Group 2 (WT and MDX Myofibers)       |
    +=================================================+======================================+
    | Peaks common to uninjured and injured Myofibers | Peaks common to WT and MDX Myofibers |
    +-------------------------------------------------+--------------------------------------+
    | Peaks unique to uninjured Myofibers             | Peaks unique to WT Myofibers         |
    +-------------------------------------------------+--------------------------------------+
    | Peaks unique to injured Myofibers               | Peaks unique to MDX Myofibers        |
    +-------------------------------------------------+--------------------------------------+

    *Table 1: Peak categories across myofiber conditions.*

    We considered peaks to be common if they overlapped by at least 1 bp, and took the intersection of each overlapping pair. While merging nearby peaks could capture broader regions of regulatory activity, we chose this stricter approach for consistency with the fixed-size peaks used in the paper.

    Then, we filtered for peaks that overlap with the promoter regions.

    ```{r}
    ## Function to clean granges
    clean_seqlevels <- function(granges){
      granges <- keepSeqlevels(granges, common_seqlevels, pruning.mode = "coarse")
      return(granges)
    }

    ## Function to obtain common and unique peaks between two GRanges objects
    obtain_peaks <- function(cond1, cond2){
      # Find overlaps
      hits <- findOverlaps(cond1, cond2)
      
      # Common peaks: intersect overlapping regions
      common_cond1 <- cond1[(queryHits(hits))]
      common_cond2  <- cond2[(subjectHits(hits))]
      common_peaks <- pintersect(common_cond1, common_cond2) #since exact peak region used
      common_peaks <- clean_seqlevels(common_peaks)
      
      # Unique peaks for cond1 (non-overlapping)
      cond1_peaks <- cond1[-unique(queryHits(hits))]
      cond1_peaks <- clean_seqlevels(cond1_peaks)
      
      # Unique peaks for cond2 (non-overlapping)
      cond2_peaks <- cond2[-unique(subjectHits(hits))]
      cond2_peaks <- clean_seqlevels(cond2_peaks)
      
      # Return as named list
      return(list(common = common_peaks, peaks1 = cond1_peaks, peaks2 = cond2_peaks))
    }

    ## Function to obtain sequences of peaks that overlap with promoters (±5 kb around the TSS)
    overlap_proms <- function(peaks_orig){
      overlap_peaks <- peaks_orig[overlapsAny(peaks_orig, proms, type="within"),]
      seqlevels(overlap_peaks) <- sub("^chr", "", seqlevels(overlap_peaks))
      seqs <- memes::get_sequence(overlap_peaks, twobit)

      return(seqs)
    }
    ```

4.  Run motif enrichment analysis

    We performed motif enrichment using MEME’s `runAME` [@mcleayMotifEnrichmentAnalysis2010a] with its defaults (i.e. `avg` scoring, one‑tailed Fisher’s test, and a shuffled background), rather than HOMER used in the original paper.

    ```{r}
    # 1. To obtain twobit name
    twobit_results <- AnnotationHub::query(ah, c("GRCm38", "twobit", "dna.primary_assembly"))

    # 2. Extract twobit files
    twobit <- ah[["AH88475"]]

    ## Function to obtain and save motifs
    obtain_motifs <- function(seqs, filename){
      res <- memes::runAme(seqs, database=convert_motifs(motifs), meme_path="/home/jesslyn/meme/bin")
      saveRDS(res, file=filename)
      return(res)
    }

    ## Function to run motif enrichment analysis
    motif_analysis_by_group <- function(cond1, cond2, filename_common, filename_cond1, filename_cond2){
      # Obtain common and unique peaks for the conditions
      peaks_results <- obtain_peaks(cond1, cond2)
      
      # Prepare the sequences
      common_seqs <- overlap_proms(peaks_results$common)
      cond1_seqs <- overlap_proms(peaks_results$peaks1)
      cond2_seqs <- overlap_proms(peaks_results$peaks2)
      
      # Motif enrichment analysis for each of the group
      ## Obtain motifs from final peaks (exact peak region)
      res_common <- obtain_motifs(common_seqs, filename_common)
      res_cond1 <- obtain_motifs(cond1_seqs, filename_cond1)
      res_cond2 <- obtain_motifs(cond2_seqs, filename_cond2)
    }

    motif_dir <- "motif_enrichment/motifs/"
    ```

    Due to difficulties installing MEME on Windows, the motif enrichment analysis chunk has been set to `eval = FALSE`. To rerun the analysis, set `eval = TRUE`.

    ```{r motif enrichment, eval=FALSE}
    motif_analysis_by_group(peaks_narrow$ui_final, peaks_narrow$i_final, paste0(motif_dir, "ui_i_motifs.rds"), paste0(motif_dir, "ui_motifs.rds"), paste0(motif_dir, "i_motifs.rds"))
    motif_analysis_by_group(peaks_narrow$mdx_final, peaks_narrow$wt_final, paste0(motif_dir, "mdx_wt_motifs.rds"), paste0(motif_dir, "mdx_motifs.rds"), paste0(motif_dir, "wt_motifs.rds"))
    ```

5.  Visualize top 5 enriched motifs for each set of peaks

    Similar to the paper, we filtered for enriched motifs within each set of peaks with an adjusted p-value less than 0.05 and ordered them based on increasing adjusted p-value.

    For brevity, only the ‘common’ peak comparisons are shown here. Motif logo plots for the unique uninjured, unique injured, unique WT, and unique MDX sets are available in Supplementary Fig. 1.

    ```{r motif visualization, fig.width=14, fig.height=10, dpi=150, fig.align='center', fig.show='hold'}
    ## Function to visualize motifs
    motif_visualization <- function(file_name, plot_title, overlap_val=0.99){
      res <- readRDS(file_name)
      filtered_res <- res[res$adj.pvalue < 0.05, ]
      filtered_res<- filtered_res[order(filtered_res$adj.pvalue, decreasing = FALSE), ]
      universalmotif::view_motifs(motifs[filtered_res[1:5, ]$motif_id], 
                                  min.overlap = overlap_val, 
                                  RC.text = "", 
                                  names.pos="right") +
        ggtitle(plot_title) +
        ggplot2::theme(plot.title = element_text(hjust = 0.5))
    }

    p1 <- motif_visualization(paste0(motif_dir, "ui_i_motifs.rds"), "(a) Top 5 motifs enriched in peaks common to Uninjured\nand Injured Myofibers overlapping the promoters")

    p2 <- motif_visualization(paste0(motif_dir, "mdx_wt_motifs.rds"), "(b) Top 5 motifs enriched in peaks common to WT\nand MDX Myofibers overlapping the promoters")
    combined <- p1 + p2 + plot_layout(ncol = 2)
    combined
    ```

    *Fig. 9: Top 5 enriched motifs in ATAC-Seq peaks overlapping the promoter regions (±5 kb) and common to (a) Uninjured and Injured Myofibers, (b) WT and MDX Myofibers.*

    Unfortunately, our results differed from the original paper’s top five enriched motifs and did not show substantial differences in motif enrichment between the different sets of peaks (Fig. 9, Table 2). This discrepancy is likely due to methodological differences between MEME (AME) and HOMER, some of which are outlined below (Table 3).

```{r, echo=FALSE, out.width="100%", fig.align='center'}

knitr::include_graphics("images/enriched_motifs_comparison.png")
```

*Table 2: Comparison of the top 5 enriched motifs identified in the paper versus our analysis (UI = Uninjured, I = Injured)*

+--------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Feature                                          | MEME (AME) [@mcleayMotifEnrichmentAnalysis2010a]                                                                                                 | HOMER (findMotifsGenome.pl) [@heinzSimpleCombinationsLineageDetermining2010]                                                                                   | Potential impact                                                                                                                                                          |
+==================================================+==================================================================================================================================================+================================================================================================================================================================+===========================================================================================================================================================================+
| Motif Databases                                  | User-defined: Here, HOCOMOCOv10 mouse from MotifDb.                                                                                              | Default: Uses a built-in motif library, which consists of a list of previously determined motifs from previous data.                                           | There could be motifs that are only present in one of the databases, which can lead to difference in the motifs that appear significantly enriched.                       |
+--------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Scoring strategy of a single sequence to a motif | Default: Calculates average motif odds score of all positions in the sequence                                                                    | ZOOPS (zero or one occurrences per sequence): Each sequence can have a maximum of one motif hit if the highest scoring match exceeds the predefined threshold. | `avg` can over‑emphasize sequences with many weak matches, whereas ZOOPS strictly counts presence or absence, affecting motif ranking regardless of the statistical test. |
|                                                  |                                                                                                                                                  |                                                                                                                                                                |                                                                                                                                                                           |
|                                                  |                                                                                                                                                  |                                                                                                                                                                | For more comparable results between these methods, `totalhits` can be used as the scoring strategy in MEME.                                                               |
+--------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Statistical testing                              | Default: one‑tailed Fisher’s exact test with partition maximization.                                                                             | Default: Binomial test                                                                                                                                         | The difference in statistical test can lead to different p-values and ranking of motifs.                                                                                  |
+--------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Background model                                 | Default: Built from input sequences, using a 0th‑order Markov model of primary sequence nucleotide frequencies, with shuffling of input sequence | Default: Background regions calculated based on the GC/CpG% at regions near the TSS of genes (±5 kb) and split into size of the analyzed regions.              | Differences in background composition, such as GC% content, can greatly affect the enrichment p-values, leading to different top motifs.                                  |
+--------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

*Table 3: Comparison of MEME (AME) and HOMER (findMotifsGenome.pl) features and their potential impact.*

Limitations:

1.  We used a naive‐overlap approach to define peaks for each condition, which yields a robust and reproducible regions but may miss true binding sites that are variable across replicates. In future work, applying an Irreproducible Discovery Rate (IDR) framework could capture a more confident and reproducible set of peaks for each condition [@hitzENCODEUniformAnalysis2023].
2.  By default, MEME’s AME tool does not correct for GC‐content bias when generating its background model. Since promoter regions (±5 kb of TSS) are inherently GC‐rich, this omission can inflate enrichment statistics for GC‐rich motifs [@heinzSimpleCombinationsLineageDetermining2010]. Indeed, our results identified several GC-rich motifs (Fig. 9, Supplementary Fig. 1), suggesting a potential bias. To address this, future analyses should employ a GC-matched background when running AME.

# Conclusion

In conclusion, we successfully reproduced and critically evaluated smfATAC‑seq profiling of single myofibers under regenerative (uninjured vs. injured) and dystrophic (WT vs. MDX) conditions. We implemented a complete preprocessing and analysis pipeline, including trimming, alignment, peak calling, consensus peak generation, normalization, differential accessibility testing, region-centric gene set enrichment (`great`), and MEME-based motif enrichment, while carefully addressing batch effects by analyzing the two experiments separately.

Similar to the findings in the original paper, we observed high correlation between all samples within an experiment, not just between replicates of a single condition. We observed larger accessibility shifts during regeneration but a greater number of subtler changes in the MDX model. Additionally, we identified key inflammatory and injury-related pathways, such as IL6–JAK–STAT3, complement activation, and Wnt/β‑catenin, which align with previous findings and the original paper. Our motif enrichment analysis differed from the original paper, likely because of methodological differences between AME and HOMER and the absence of GC-matched backgrounds. This demonstrates that the choice of analytical tools can influence results, which in turn impacts biological interpretation. Nevertheless, both our analysis and the original paper successfully demonstrated how chromatin accessibility changes under different conditions in smfATAC-seq data.

# References

::: {#refs}
:::

# Appendix {.unnumbered}

## Supplementary Table 1

| Condition   | SRA Accession Number |
|-------------|----------------------|
| Uninjured_1 | SRR14371953          |
| Uninjured_2 | SRR14371954          |
| Injured_1   | SRR14371955          |
| Injured_2   | SRR14371956          |
| Injured_3   | SRR14371957          |
| MDX_1       | SRR15343189          |
| MDX_2       | SRR15343190          |
| MDX_3       | SRR15343191          |
| WT_1        | SRR15343192          |
| WT_2        | SRR15343193          |
| WT_3        | SRR15343194          |
| WT_4        | SRR15343195          |

*Supplementary Table 1: SRA Accession Number used in this report with its corresponding condition.*

## Code for Generating Figure 2 (Main Text)

The following Python code was used to generate the alignment summary plot shown in the main body of the report.

```{python, eval=FALSE}
pip install pandas matplotlib seaborn

import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.ticker as mticker
import seaborn as sns

df=pd.read_csv("preprocessing/results/alignment/bowtie_stats.csv", sep=';')

sns.set(style='whitegrid')
fig, ax = plt.subplots(figsize=(10, 6))

df.set_index('Sample')[['Unique', 'MultiMapped', 'Unmapped']].plot(
    kind='barh',
    stacked=True,
    color={'Unique':'#1f78b4', 'MultiMapped':'#a6cee3', 'Unmapped':'#e31a1c'},
    ax=ax
)

ax.xaxis.set_major_formatter(mticker.FuncFormatter(lambda x, pos: f'{int(x/1e6)}M'))

ax.set_xlabel('Read count')
ax.set_title('Alignment summary')
plt.tight_layout()
plt.show()
```

## Supplementary Fig. 1

```{r, fig.width=14, fig.height=20, dpi=150, fig.show='hold'}

p1 <- motif_visualization(paste0(motif_dir, "ui_motifs.rds"), plot_title="(a) Top 5 motifs enriched in peaks unique to\nUninjured Myofibers overlapping the promoters")
p2 <- motif_visualization(paste0(motif_dir, "i_motifs.rds"), plot_title="(b) Top 5 motifs enriched in peaks unique to\nInjured Myofibers overlapping the promoters")

p3 <- motif_visualization(paste0(motif_dir, "wt_motifs.rds"), plot_title="(c) Top 5 motifs enriched in peaks unique\nto WT Myofibers overlapping the promoters")
p4 <- motif_visualization(paste0(motif_dir, "mdx_motifs.rds"), plot_title="(d) Top 5 motifs enriched in peaks unique\nto MDX Myofibers overlapping the promoters")

combined <- (p1 + p2) / plot_spacer() / (p3 + p4) +  plot_layout(heights = c(1, 0.02, 1))
    combined
```

*Supplementary Figure 1: Top 5 enriched motifs in ATAC-Seq peaks overlapping the promoter regions (±5 kb) and unique to (a) Uninjured Myofibers, (b) Injured Myofibers, (c) WT Myofibers, (d) MDX Myofibers.*

## Session Information

```{r}
sessionInfo()
```

## Bash Packages

Packages used to run the following scripts: 1_trim.sh, 2_align.sh, 3_merge_bam.sh, 4_peak_calling.sh, 5_condition_peaks.sh, 7_matrix_gen.sh

```{r}
env <- yaml::read_yaml("preprocessing/bash_environment/main_bash.yml")
print(env)
```

Packages used to run the following script: 6_coverage.sh

```{r}
env <- yaml::read_yaml("preprocessing/bash_environment/coverage_bash.yml")
print(env)
```
